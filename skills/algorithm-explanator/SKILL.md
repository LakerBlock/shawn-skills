---
name: algorithm-explanator
description: 通用算法解释框架。用直观的比喻、逐步图解、代码对照的方式解释任何算法问题的核心思路、变量设计逻辑、循环结构设计的思考过程。适用于面试时如何有条理地分析和讲解算法题。
---

# 通用算法解释框架

> **核心原则**：用小学生也能理解的比喻 + 逐步图解 + 代码对照，让算法变得直观

---

## 使用流程

### 首次使用

询问用户保存路径（每一个对话当中都需要询问用户想要保存的路径）。

### 每次使用

1. 询问题目信息：
   - 题目名称
   - 题目链接（可选）
   - 代码实现（可选，用于生成背诵模板）

2. 自动生成完整解释并保存为 `{题目名称}.md`

---

## 一、问题分析

### 1.1 一句话理解

把问题翻译成日常生活中的场景：

```
原始描述：...
生活翻译：...
```

### 1.2 关键洞察

问自己三个问题：

1. **有多少种状态？** → 决定变量数量
2. **状态如何转换？** → 决定状态转移方程
3. **初始状态是什么？** → 决定初始值

---

## 二、变量设计（核心）

### 2.1 核心状态提炼

**有哪些状态？**

```
状态1：...
状态2：...
```

### 2.2 通俗解释

**用"两个口袋"比喻**：

```
口袋 A：不持股时，最多能剩多少钱？
口袋 B：持股时，这支股票值多少钱？
```

### 2.3 循环逻辑（整合）

**为什么这样遍历？**

```
外层遍历天数：每天都需要做决策
内层遍历限制：计算"最多 j 次交易"的所有情况

比喻：有 k+1 个平行世界
  世界0：0次交易
  世界1：最多1次交易
  ...
  世界k：最多k次交易 ← 我们要的结果
```

### 2.4 代码对照

```python
# 初始状态
hold = [0] * (k + 1)              # 不持股 = 0 元
not_hold = [-prices[0]] * (k + 1) # 持股 = 花掉的钱（负数）
```

---

## 三、完整图解（帮助理解的核心）

### 3.1 示例

```
prices = [3, 2, 6], k = 2
```

### 3.2 初始化

```
第1天：
hold = [0, 0, 0]
not_hold = [-3, -3, -3]
```

### 3.3 逐天演示

```
第2天（price = 2）：
  j=1: hold[1] = max(0, -3+2) = 0
       not_hold[1] = max(-3, 0-2) = -2
  j=2: hold[2] = max(0, -3+2) = 0
       not_hold[2] = max(-3, 0-2) = -2

结果：hold = [0, 0, 0], not_hold = [-3, -2, -2]

第3天（price = 6）：
  j=1: hold[1] = max(0, -3+6) = 3
       not_hold[1] = max(-2, 0+6) = 4
  j=2: hold[2] = max(0, -2+6) = 4
       not_hold[2] = max(-2, 0+6) = 4

结果：hold = [0, 3, 4], not_hold = [-3, 4, 4]
```

### 3.4 答案验证

```
return hold[2] = 4

验证：第2天买入(2) → 第3天卖出(6) = 赚 4 元 ✓
```

---

## 四、核心公式

### 4.1 状态转移方程

```
新状态 = max(保持现状, 做交易)

不持股 = max(保持不卖, 卖出换钱)
持股   = max(保持不买, 花钱买入)
```

### 4.2 代码对照

```python
# 不持股：要么保持，要么卖出
hold[j] = max(hold[j], not_hold[j-1] - price)

# 持股：要么保持，要么买入
not_hold[j] = max(not_hold[j], hold[j] + price)
```

### 4.3 关键问题：为什么用 j-1？

**买入用 `not_hold[j-1]`，卖出用 `hold[j]`？**

- **买入**：增加交易次数（用掉一次机会）→ 从 j-1 来
- **卖出**：只是完成交易，不增加次数 → 保持 j

---

## 五、面试答题模板

### 5.1 5分钟答题结构

```
1. 问题复述（1分钟）
   "这道题是...，核心是...，限制条件是..."

2. 核心洞察（1分钟）
   "我观察到这个问题只有两种状态：持股和不持股..."

3. 状态定义（1分钟）
   "我需要两个变量：
    hold[j] - 最多j次交易后不持股的最大利润
    not_hold[j] - 最多j次交易后持股的最大利润"

4. 状态转移（1.5分钟）
   "对于不持股：要么保持不卖，要么卖出换钱
    对于持股：要么保持不买，要么买入"

5. 初始化与答案（0.5分钟）
   "初始时，不持股为0，持股为负的第1天价格。最终返回 hold[k]"
```

---

## 六、完整代码

```python
def maxProfit(k, prices):
    n = len(prices)
    if n == 0:
        return 0

    # 特殊情况：k 足够大，退化为无限次交易
    if k >= n // 2:
        profit = 0
        for i in range(1, n):
            if prices[i] > prices[i-1]:
                profit += prices[i] - prices[i-1]
        return profit

    # 动态规划
    hold = [0] * (k + 1)              # 不持股
    not_hold = [-prices[0]] * (k + 1) # 持股

    for price in prices[1:]:
        for j in range(1, k + 1):
            prev_hold = hold[j]
            prev_not_hold = not_hold[j]

            hold[j] = max(hold[j], not_hold[j-1] - price)
            not_hold[j] = max(not_hold[j], prev_hold + price)

    return hold[k]
```

---

## 七、代码背诵记忆

### 7.1 三段式背诵法

**第一段：框架（是什么）**
```
□ 函数定义
□ 边界处理
□ 特殊情况优化
```

**第二段：初始化（起点）**
```
□ hold 数组初始化
□ not_hold 数组初始化
```

**第三段：核心循环（怎么做）**
```
□ 外层遍历价格
□ 内层遍历交易次数
□ 状态转移方程
□ 返回结果
```

### 7.2 逐句记忆口诀

| 代码 | 口诀 | 含义 |
|------|------|------|
| `hold = [0] * (k+1)` | "不持股，从零起" | 不持股时利润为0 |
| `not_hold = [-p[0]] * (k+1)` | "持股花本钱" | 持股时花了钱，是负数 |
| `for price in prices[1:]` | "一天一天走" | 遍历每一天 |
| `for j in range(1, k+1)` | "一次一次算" | 遍历交易次数 |
| `hold[j] = max(...)` | "卖不卖，选最大" | 不持股的最优选择 |
| `not_hold[j] = max(...)` | "买不买，选最大" | 持股的最优选择 |
| `return hold[k]` | "最后看口袋" | 返回不持股的最大利润 |

### 7.3 手写填空模板

```python
def maxProfit(k, prices):
    n = len(prices)
    if n == 0:
        return ____

    if k >= n // 2:
        profit = 0
        for i in range(1, n):
            if prices[i] > prices[i-1]:
                profit += ____________
        return profit

    hold = [____] * (k + 1)
    not_hold = [________] * (k + 1)

    for price in prices[____:]:
        for j in range(____, k + 1):
            hold[j] = max(hold[j], _________________)
            not_hold[j] = max(not_hold[j], _________________)

    return hold[____]
```

**答案**：0, prices[i]-prices[i-1], 0, -prices[0], 1, 1, not_hold[j-1]-price, hold[j]+price, k

### 7.4 易错点提醒

| 易错点 | 正确做法 | 常见错误 |
|--------|----------|----------|
| 数组长度 | `k+1`（包含0次交易） | 写成 k |
| not_hold初始值 | `-prices[0]`（负数） | 写成正数 |
| 买入用 j-1 | `not_hold[j-1] - price` | 写成 j |
| 卖出用 j | `hold[j] + price` | 写成 j-1 |
| 遍历起点 | `prices[1:]`（第2天开始） | 从第1天开始 |
| 返回值 | `hold[k]`（不持股） | 写成 not_hold |

---

## 八、扩展思考

### 8.1 贪心优化

当 `k >= n/2` 时，问题退化为无限次交易，可以用贪心 O(n) 解决。

### 8.2 空间优化

状态只依赖上一轮，可以用滚动数组进一步压缩空间。

### 8.3 变体问题

- 买卖股票 II：无限次交易
- 买卖股票 V：卖出后冷冻一天
