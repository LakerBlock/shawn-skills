---
name: algorithm-explanator
description: 通用算法解释框架。用直观的比喻、逐步图解、代码对照的方式解释任何算法问题的核心思路、变量设计逻辑、循环结构设计的思考过程。适用于面试时如何有条理地分析和讲解算法题。
---

# 通用算法解释框架

> **核心原则**：用小学生也能理解的比喻 + 逐步图解 + 代码对照，让算法变得直观

---

## 一、问题分析（3分钟快速理解）

### 1.1 这道题在问什么？

**用一句话概括问题本质**：

```
把问题翻译成日常生活中的场景，越简单越好
```

**例子（股票交易）**：
- 原始描述："给定数组 prices，找到最多 k 次交易的最大利润"
- 生活翻译："你是一个股票贩子，每天有个价格，你可以买卖多次但手里只能有一支股票，最多做 k 笔生意，最多能赚多少钱？"

### 1.2 核心约束是什么？

列出所有限制条件：

| 约束 | 含义 | 影响 |
|------|------|------|
| 约束1 | 手里只能有一支股票 | 买入前必须先卖出 |
| 约束2 | 最多 k 次交易 | 需要限制交易次数 |

### 1.3 关键洞察

问自己三个问题：

1. **有多少种状态？** → 决定了需要几个变量
2. **状态如何转换？** → 决定了状态转移方程
3. **初始状态是什么？** → 决定了初始值如何设置

---

## 二、变量设计（为什么这样定义？）

### 2.1 核心状态提炼

**关键问题**：这个问题有哪些"状态"？

```
股票问题只有两种状态：
1. 持股状态（手里有股票）
2. 不持股状态（手里没有股票）
```

### 2.2 变量的通俗解释

**用"两个口袋"的比喻**：

```
口袋 A（cash）：不持股时，最多能剩多少钱？
口袋 B（hold）：持股时，这支股票值多少钱？
```

### 2.3 为什么要这样定义？

**思考过程**：

1. **问**：我需要记录什么信息才能做决策？
2. **答**：如果我想知道要不要卖，我需要知道"如果我卖了能得多少钱"；如果我想知道要不要买，我需要知道"如果我买了要花多少钱"。
3. **结论**：所以需要两个变量，一个记录不持股的价值，一个记录持股的价值。

### 2.4 代码对照

```python
# 初始状态
hold = [0] * (k + 1)              # 口袋 A：0 次交易，不持股 = 0 元
not_hold = [-prices[0]] * (k + 1) # 口袋 B：0 次交易，持股 = 花掉的钱

# 为什么是负数？
# 因为买入时花了钱，所以 "股票价值 - 花掉的钱 = 负数"
```

---

## 三、循环设计（为什么这样遍历？）

### 3.1 外层循环：时间维度

**问题**：为什么需要遍历天数？

**回答**：因为每天都需要做决策

```python
for price in prices[1:]:  # 第1天用于初始化，从第2天开始做决策
```

**图解**：

```
第1天：初始化两个口袋
第2天：做决策
第3天：做决策
...
第n天：做决策
```

### 3.2 内层循环：限制维度

**问题**：为什么需要遍历 k？

**回答**：因为我们要计算"最多 j 次交易"的所有情况

**比喻**：有 k+1 个平行世界

```
世界0：0次交易 ← 不能买卖
世界1：最多1次交易
世界2：最多2次交易
...
世界k：最多k次交易 ← 我们要的结果
```

### 3.3 嵌套循环的直观理解

```
for 每天 in [第2天, 第3天, ..., 第n天]:
    for 交易次数上限 in [1次, 2次, ..., k次]:
        # 问：如果我今天只能用"交易次数上限"次交易，
        #     我的两个口袋应该变成什么样？
```

---

## 四、核心公式（状态转移）

### 4.1 公式模板

```
新状态 = max(保持现状, 做交易)
```

### 4.2 直观理解

```
┌─────────────────────────────────────────────────────────────┐
│                                                             │
│   不持股 = max(保持不卖, 卖出换钱)                            │
│   持股   = max(保持不买, 花钱买入)                            │
│                                                             │
└─────────────────────────────────────────────────────────────┘
```

### 4.3 代码对照

```python
# 不持股：要么保持，要么卖出
hold[j] = max(hold[j], not_hold[j-1] - price)

# 持股：要么保持，要么买入
not_hold[j] = max(not_hold[j], hold[j] + price)
```

### 4.4 关键问题：为什么用 j-1？

**问**：买入为什么用 `not_hold[j-1]`，卖出为什么用 `hold[j]`？

**答**：因为买入会增加交易次数（用掉一次机会），卖出不会

| 操作 | 交易次数 | 原因 |
|------|---------|------|
| 买入 | j-1 → j | 用掉一次交易机会 |
| 卖出 | j | 只是完成交易，不增加次数 |

---

## 五、完整图解（手把手演示）

### 5.1 示例

```
prices = [3, 2, 6], k = 2
```

### 5.2 第 1 天：初始化

```
hold = [0, 0, 0]
not_hold = [-3, -3, -3]
```

### 5.3 第 2 天：price = 2

```
j = 1:
  hold[1] = max(0, -3+2) = 0
  not_hold[1] = max(-3, 0-2) = -2

j = 2:
  hold[2] = max(0, -3+2) = 0
  not_hold[2] = max(-3, 0-2) = -2

结果：
hold = [0, 0, 0]
not_hold = [-3, -2, -2]
```

### 5.4 第 3 天：price = 6

```
j = 1:
  hold[1] = max(0, -3+6) = 3
  not_hold[1] = max(-2, 0+6) = 4

j = 2:
  hold[2] = max(0, -2+6) = 4
  not_hold[2] = max(-2, 0+6) = 4

结果：
hold = [0, 3, 4]
not_hold = [-3, 4, 4]
```

### 5.5 最终答案

```python
return hold[2]  # = 4
```

**验证**：第2天买入(2) → 第3天卖出(6) = 赚 4 元 ✓

---

## 六、面试答题模板

### 6.1 标准答题结构（5分钟版）

```
1. 问题复述（1分钟）
   "这道题是...，核心是...，限制条件是..."

2. 核心洞察（1分钟）
   "我观察到这个问题只有两种状态：持股和不持股..."

3. 状态定义（1分钟）
   "我需要两个变量：
    hold[j] - 最多j次交易后不持股的最大利润
    not_hold[j] - 最多j次交易后持股的最大利润"

4. 状态转移（1.5分钟）
   "对于不持股：
      要么保持不卖，要么卖出换钱 → hold[j] = max(hold[j], not_hold[j-1] - price)
    对于持股：
      要么保持不买，要么买入 → not_hold[j] = max(not_hold[j], hold[j] + price)"

5. 初始化与答案（0.5分钟）
   "初始时，不持股为0，持股为负的第1天价格。最终返回 hold[k]"
```

### 6.2 关键句式

| 场景 | 句式 |
|------|------|
| 定义变量 | "我需要记录...，所以定义变量..." |
| 解释循环 | "外层遍历...，因为...；内层遍历...，因为..." |
| 解释公式 | "这个公式表示...，有两种选择：..." |
| 解释初始化 | "初始值为...，因为..." |

---

## 七、通用框架总结

### 7.1 分析任何算法的模板

```
Step 1: 问题翻译 → 把算法题翻译成生活场景
Step 2: 状态提炼 → 有几种状态？每种状态代表什么？
Step 3: 变量定义 → 为什么这样定义？初始值是多少？
Step 4: 循环设计 → 为什么这样遍历？外层是什么，内层是什么？
Step 5: 状态转移 → 状态如何变化？核心公式是什么？
Step 6: 边界处理 → 特殊情况怎么处理？
```

### 7.2 一句话记忆

> **"状态→变量→循环→公式"，每个环节问自己三个问题：是什么？为什么？怎么做？**

### 7.3 示例应用

以"股票交易 k 次"为例：

| 步骤 | 内容 |
|------|------|
| 问题翻译 | 股票贩子最多做 k 笔生意 |
| 状态提炼 | 两种状态：持股、不持股 |
| 变量定义 | hold 和 not_hold 两个数组 |
| 循环设计 | 外层遍历天数，内层遍历交易次数 |
| 状态转移 | 新状态 = max(保持, 交易) |
| 边界处理 | 空数组、k=0、k 很大的情况 |

---

## 八、完整代码（最终版本）

```python
def maxProfit(k, prices):
    n = len(prices)
    if n == 0:
        return 0

    # 特殊情况：k 足够大，退化为无限次交易
    if k >= n // 2:
        profit = 0
        for i in range(1, n):
            if prices[i] > prices[i-1]:
                profit += prices[i] - prices[i-1]
        return profit

    # 动态规划
    hold = [0] * (k + 1)              # 不持股
    not_hold = [-prices[0]] * (k + 1) # 持股

    for price in prices[1:]:
        for j in range(1, k + 1):
            prev_hold = hold[j]
            prev_not_hold = not_hold[j]

            hold[j] = max(hold[j], not_hold[j-1] - price)
            not_hold[j] = max(not_hold[j], prev_hold + price)

    return hold[k]
```

---

## 九、扩展思考

### 9.1 贪心优化

当 `k >= n/2` 时，问题退化为无限次交易，可以用贪心 O(n) 解决。

### 9.2 空间优化

状态只依赖上一轮，可以用滚动数组进一步压缩空间。

### 9.3 变体问题

- 买卖股票 II：无限次交易
- 买卖股票 V：卖出后冷冻一天

---

## 十、一句话总结

> **"两个口袋记录每天的最佳选择：每天比较'保持现状'和'做交易'哪个更好。"**
